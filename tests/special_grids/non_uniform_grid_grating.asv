close all
clear

%% testing the non-uniform mesh in real FDFD simulations


%% Set up the domain parameters.
L0 = 1e-6;  % length unit: microns
c0 = 3e8;

%% non-uniform grid specification
% 1) partition into coarse vs fine (vs pml)
% along a line, it looks like Ncoarse, Nfine, Ncoarse
% in this construction scheme, we actually do not set the full domain size
% in the initial case

Nfine = [100,100]; %specify nx, ny for each region
Ncoarse = [50,50];
Ntran =   [50,50];

% 2) specify the dx and dy of each region
dx1 = 0.02; dy1 = 0.02;
dx2 = 0.005; dy2 = 0.005;
dfine = [dx2, dy2];
dcoarse = [dx1, dy1];
dtran = [0 ,0];

% 3) stack the vectors
% drt does not have a value...
Nft = vertcat(Ncoarse, Ntran, Nfine, Ntran, Ncoarse);
drt = vertcat(dcoarse, dtran, dfine, dtran, dcoarse);

% scale is arbitrary, just take dcoarse;
dr_reference  = dcoarse;

% 4) construct scaling vectors from this information
[dx_scale, dy_scale] = generate_nonuniform_scaling(Nft, drt./dr_reference);

%% calculate Ntot and Ltot
N = sum(Nft);
Lx = sum(dr_reference(1)*dx_scale);
Ly = sum(dr_reference(2)*dy_scale);
L = [Lx, Ly];
xrange = 0.5*[-Lx, Lx];
yrange = 0.5*[-Ly, Ly];
xrange_array = cumsum(dr_reference(1)*dx_scale)-Lx/2;
yrange_array = cumsum(dr_reference(1)*dy_scale)-Ly/2;
Nx = N(1); Ny = N(2);
%% output is a dxscale...dyscale


%% PML specification
Npml = [20,20];

%% Set up the permittivity.
wvlen = 1;
omega = 2*pi*c0/wvlen*1e6;
eps = ones(N);
thickness = 0.5;

% x_center and y_center should be values ACTUALLY in xrange array
% it should be the users responsibility to do that...
x_center = 0;
y_center = 0;
fill_factor = 0.2;
lattice_constant= L(1);
epsilon_center = 12;

N = size(eps);
Nx = N(1); Ny = N(2);
Lx = xrange_array(end)-xrange_array(1); 
Ly = yrange_array(end)-yrange_array(1);

% in order to do this kind of mapping, we have to find the x and y
% in xrange array and y range array closest to xcenter and ycenter
[cx,  nu_x_center] = min(abs(x_center-xrange_array));
[cy,  nu_y_center] = min(abs(y_center-yrange_array));

metal_size = fill_factor*lattice_constant; %in physical units

%% get metal bounds
rightx = x_center+metal_size/2;
leftx = x_center-metal_size/2;

% get indices closest to rightx and righty
[~,  rhalf] = min(abs(rightx-xrange_array));
[~,  lhalf] = min(abs(leftx-yrange_array));

%% get y bounds
upper_y = y_center +thickness/2;
lower_y = y_center - thickness/2;
[~,  bhalf] = min(abs(upper_y-xrange_array));
[~,  thalf] = min(abs(lower_y-yrange_array));
eps(:, nu_y_center-halfy:nu_y_center+halfy) = -2;
eps(:, nu_y_center-halfy:nu_y_center+halfy) = -2;

eps(lhalf: rhalf,...
    nu_y_center-halfy:nu_y_center+halfy) = epsilon_center;



figure(); 
visreal_nu(eps, xrange_array, yrange_array,0);


